# QAMP Project: Local and Multi-Scale Strategies to Mitigate Exponential Concentration in Quantum Kernels

---

**Development:** kernels are developed as independent workstreams (Global, Local, Multi-Scale).  
**Goal:** show that Local/Multi-Scale kernels mitigate exponential concentration and provide better or more robust performance than the Global (fidelity) baseline, with clear diagnostics.

---

## Project plan

See **[PLAN.md](./PLAN.md)** for scope, shared interfaces, artifacts, and milestones.

---

## 1) Overview

Quantum fidelity kernels tend to **concentrate** as qubits/depth grow, making the kernel matrix close to identity and hurting learning.
We evaluate two practical fixes:

* **Local (patch-wise) kernels:** compare **reduced** subsystems (subcircuits or reduced density matrices, RDMs), then aggregate.
* **Multi-Scale kernels:** combine similarities computed at **multiple granularities** (e.g., pairs -> all qubits).

We implement three kernels in Qiskit, run small benchmarks (synthetic + one small tabular), and produce reproducible diagnostics and figures.

---

## 2) Repository layout

```
project/
  qkernels/
    __init__.py
    feature_maps.py          # shared quantum feature maps (e.g., ZZ entangling), depth control
    baseline_kernel.py       # fidelity-based global kernel (baseline, no locality)
    local_kernel.py          # patch-wise kernel: per-partition similarities (subcircuits or RDMs) + aggregation
    multiscale_kernel.py     # multi-scale kernel: combines per-scale kernels with weights; supports ablations
  analysis/
    diagnostics.py           # heatmap, off-diag histogram, eigen-spectrum
    eval_svm.py              # SVM with precomputed kernels
  scripts/
    run_experiment.py        # loads config.toml, orchestrates runs
  tests/                     # pytest unit tests (API contracts, kernels, diagnostics, scripts)
  outputs/                   # K.npy, splits_*.json, meta_*.json, metrics.csv
  figs/                      # figures generated by diagnostics
  docs/                      # short documentation and runnable command recipes (e.g., RECIPES.md)
  config.toml                # single source of truth for runs
  PLAN.md                    # team plan (scope & milestones)
  README.md                  # this file
```

---

## 3) Installation

* **Python:** 3.10+ recommended
* **Create env** (example with `venv`):

  ```bash
  python -m venv .venv
  source .venv/bin/activate   # Windows: .venv\Scripts\activate
  ```
* **Install deps**:

  ```bash
  pip install -U pip
  pip install -r requirements.txt
  ```

---

## 4) Configuration (`config.toml`)

All runs read a single TOML file so results remain comparable across runs and environments.

```toml
# -- Global run settings --
[run]
seed = 42
dataset = "make_circles"      # "make_circles" | "iris"
n_samples = 150               # ignored for iris (uses full set)
test_size = 0.2
val_size  = 0.2

# -- Shared feature map --
[feature_map]
name = "zz"
depth = 1
backend = "statevector"       # "statevector" | "sampling"
shots = 0                     # 0 => statevector; >0 => sampling

# -- Kernels (enable/disable individually) --
[baseline_kernel]
enabled = true

[local_kernel]
enabled = true
partitions = [[0,1],[2,3]]    # contiguous pairs
method = "subcircuits"        # "subcircuits" | "rdm"
agg = "mean"                  # "mean" | "weighted"
weights = []                  # [] => equal weights

[multiscale_kernel]
enabled = true
scales = [
  [[0,1],[2,3]],              # S1: pairs
  [[0,1,2,3]]                 # S2: all
]
weights = [0.5, 0.5]          # initial mixing

# -- SVM baseline using precomputed kernels --
[svm]
C = [0.1, 1.0, 10.0]

[paths]
outputs = "outputs"
figs    = "figs"
```

> We keep this file as the **single source of truth** (datasets, seeds, partitions, scales, paths).

---

## 5) Unified Kernel API

All three kernel modules must expose the same function:

```python
def build_kernel(
    X,                      # np.ndarray (n_samples, d)
    feature_map="zz",
    depth=1,
    backend="statevector",  # "statevector" | "sampling"
    seed=42,
    **kwargs                # kernel-specific
):
    """
    Returns:
      K    : np.ndarray (n, n)  # symmetric, ~PSD, float64
      meta : dict               # full config (for logging)
    """
```

Kernel-specific `**kwargs`:

* **Global:** optional `shots`, `noise_model`.
* **Local:** `partitions`, `method="subcircuits"|"rdm"`, `agg`, `weights`.
* **Multi-Scale:** `scales`, `weights`.

---

## 6) Quickstart

### Ready-to-run recipes
For copy-paste one-liners on `make_circles` and `iris` (Baseline, Local-only, Multi-Scale), see **[docs/RECIPES.md](docs/RECIPES.md)**.

### 6.1 Generate kernels & figures (all enabled kernels in `config.toml`)

```bash
python scripts/run_experiment.py --config example.toml
```

This produces, per kernel & dataset:

* `outputs/K_{kernel}-{dataset}_{seed}.npy`
* `outputs/meta_{kernel}-{dataset}_{seed}.json`
* `outputs/splits_{dataset}_{seed}.json` (shared)
* `figs/{kernel}-{dataset}_{seed}_matrix.png`
* `figs/{kernel}-{dataset}_{seed}_offdiag_hist.png`
* `figs/{kernel}-{dataset}_{seed}_spectrum.png`

### 6.2 Evaluate SVM (precomputed)

```bash
python analysis/eval_svm.py \
  --kernel outputs/K_local-make_circles_42.npy \
  --splits outputs/splits_make_circles_42.json \
  --C 0.1 1 10 \
  --out outputs/metrics.csv
```

### 6.3 Diagnostics only (from an existing `K.npy`)

```bash
python analysis/diagnostics.py \
  --kernel outputs/K_global-make_circles_42.npy \
  --labels outputs/splits_make_circles_42.json \
  --save-prefix figs/global-make_circles_42
```

*(CLI flags are suggestions; adjust to actual script interfaces.)*

---

## 7) Artifacts & naming

* **Kernel matrix:** `outputs/K_{kernel}-{dataset}_{seed}.npy`
* **Metadata:** `outputs/meta_{kernel}-{dataset}_{seed}.json`
* **Splits:** `outputs/splits_{dataset}_{seed}.json`
* **Figures:**

  * `..._matrix.png` (heatmap)
  * `..._offdiag_hist.png` (off-diagonal histogram)
  * `..._spectrum.png` (eigen-spectrum)

---

## 8) Quality checklist (run locally per kernel)

* **Shape:** `K.shape == (n, n)`; diagonals reasonable (≈1 for fidelity-style).
* **Symmetry:** `||K - K.T||_∞ < 1e-8`.
* **PSD (numerical):** `min(eigvals(K)) > -1e-8`; else regularize `K += 1e-6 I`.
* **Determinism:** fixed `seed` ⇒ same `K` and plots.
* **Timing:** log runtime for `n≈100` in `meta.json`.

---

## 9) Datasets & baselines

* **Datasets:** start with `make_circles` (binary) and **Iris** (3-class).
* **Splits & seeds:** 60/20/20, `seed=42` (save once, reuse).
* **Feature map:** `zz` with depth `1` (later `2`).
* **Classical baselines:** SVM-RBF / SVM-Poly on raw features (small grids).
* **Quantum baselines:** Global vs Local vs Multi-Scale, identical feature map.

---

## 10) Milestones (async)

* **Milestone 1 - Sun, Nov 16, 2025:**  
  For `make_circles` (~150 samples), upload the following **for each kernel**: `K.npy`, three plots, and `meta.json`.

* **Milestone 2 - Sun, Dec 14, 2025:**  
  Repeat for **Iris** and add SVM accuracy to `outputs/metrics.csv`.

* **Stretch - by Thu, Jan 30, 2026 (MVP):**  
  One dataset where Local or Multi-Scale clearly wins or is more robust.


---

## 11) Contributing

* One module per kernel (`baseline_kernel.py`, `local_kernel.py`, `multiscale_kernel.py`).
* **Do not** duplicate feature maps: use `qkernels/feature_maps.py`.
* Keep the **Unified Kernel API** signature.
* Save artifacts with the naming scheme above.
* Small PRs; no self-merge (ideally); add `meta.json` + figures for any new result.

---

## 12) Troubleshooting

* **Kernel not PSD:** add `+1e-6 I`, use `float64`, ensure exact symmetry `(K+K.T)/2`.
* **Inconsistent results across runs/environments:** verify `config.toml`, `splits_*.json`, and `seed`.
* **Slow runs:** keep depth 1–2, reduce `n`, cache circuits, prefer `statevector` first.
* **Inconsistent shapes:** confirm the same sample ordering for all kernels/splits.

---

## 13) License & citation

* **License:** *TBD* (MIT suggested).
* If you use this code in a paper or blog, please cite the project and the relevant kernel/QML references.

---

## 14) Glossary (quick)

* **PSD:** Positive Semi-Definite (valid kernel property; eigenvalues ≥ 0).
* **MCC:** Matthews Correlation Coefficient (robust classification metric).
* **RDM:** Reduced Density Matrix (state of a subsystem after partial trace).
* **TOML:** Simple, human-readable configuration format.

---

> **Status notice:** This README is under active, iterative updates during the project development.  
> We will remove this notice once the project is finalized.
